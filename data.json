{"two-sum":{"date":"Mon Jan 06 2025","questiontitle":"two-sum","code":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n\n        map = {}\n        for i in range(len(nums)):\n\n            diff = target - nums[i]\n            if diff in map:\n                return [map[diff], i]\n            map[nums[i]] = i\n\n        ","question":"<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than <code>O(n<sup>2</sup>)</code><font face=\"monospace\">&nbsp;</font>time complexity?","platform":"leetcode","difficulty":"Easy","tags":["array","hash-table"],"qlink":"https://leetcode.com/problems/two-sum","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/two-sum"},"Sum-of-Natural-Numbers":{"date":"Mon Jan 06 2025","questiontitle":"Sum-of-Natural-Numbers","code":"\nclass Solution:\n    def seriesSum(self, n : int) -> int:\n        # code here\n        \n        return (n * (n+1)) // 2\n        \n\n\n\n#{ \n # Driver Code Starts\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n\n        n = int(input())\n\n        obj = Solution()\n        res = obj.seriesSum(n)\n\n        print(res)\n        print(\"~\")\n\n# } Driver Code Ends","question":"<div class=\"problems_problem_content__Xm_eO\"><p><span style=\"font-size: 14pt;\"><span style=\"color: #1e2229; font-family: Nunito; background-color: #ffffff;\">Given an integer </span><span style=\"box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: #1e2229; background-color: #ffffff; font-family: var(--gfg-font-secondary) !important;\">n</span><span style=\"color: #1e2229; font-family: Nunito; background-color: #ffffff;\">, your task is to compute the sum of all natural numbers from 1 to n (inclusive). If n is 0, the sum should be 0.</span></span></p>\n<p><span style=\"font-size: 14pt;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 14pt;\"><strong>Input: </strong>n = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> For n = 1, the sum will be 1.\n</span></pre>\n<pre><span style=\"font-size: 14pt;\"><strong>Input: </strong>n = 5\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> For n = 5, sum will be 15. 1 + 2 + 3 + 4 + 5 = 15.</span></pre>\n<p><span style=\"font-size: 14pt;\"><strong>Constraints:</strong><br>1 &lt;= n &lt;= 10<sup>4</sup></span></p></div>","platform":"leetcode","difficulty":"Difficulty: Basic","tags":[],"qlink":"https://leetcode.com/problems/Sum-of-Natural-Numbers","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/Sum-of-Natural-Numbers"},"string-matching-in-an-array":{"date":"Tue Jan 07 2025","questiontitle":"string-matching-in-an-array","code":"class Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n\n        words.sort(key = lambda x:(len(x)))\n\n        ans = []\n        n = len(words)\n\n        for i in range(n):\n\n            for j in range(i+1, n):\n\n                if words[i] in words[j]:\n                    ans.append(words[i])\n                    break\n        \n        return ans\n        ","question":"<p>Given an array of string <code>words</code>, return <em>all strings in </em><code>words</code><em> that is a <strong>substring</strong> of another word</em>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters within a string</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]\n<strong>Output:</strong> [&quot;as&quot;,&quot;hero&quot;]\n<strong>Explanation:</strong> &quot;as&quot; is substring of &quot;mass&quot; and &quot;hero&quot; is substring of &quot;superhero&quot;.\n[&quot;hero&quot;,&quot;as&quot;] is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;]\n<strong>Output:</strong> [&quot;et&quot;,&quot;code&quot;]\n<strong>Explanation:</strong> &quot;et&quot;, &quot;code&quot; are substring of &quot;leetcode&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> No string of words is substring of another string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> contains only lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>\n</ul>\n","platform":"leetcode","difficulty":"Easy","tags":["array","string","string-matching"],"qlink":"https://leetcode.com/problems/string-matching-in-an-array","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/string-matching-in-an-array"},"count-prefix-and-suffix-pairs-i":{"date":"Wed Jan 08 2025","questiontitle":"count-prefix-and-suffix-pairs-i","code":"class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n\n        #words.sort(key = lambda x:(len(x)))\n        n = len(words)\n        ans = 0\n\n        for i in range(n):\n            for j in range(i+1, n):\n\n                if self.isPrefixAndSuffix(words[i], words[j]):\n                    ans += 1\n        \n        return ans\n\n    def isPrefixAndSuffix(self, str1, str2):\n\n        n = len(str1)\n\n        if len(str2) < n:\n            return False\n\n        print(str1)\n        print(str2)\n\n        print(str2[:n])\n        print(str2[-n:])\n        \n        cond1 = str1 == str2[:n]\n        cond2 = str1 == str2[-n:]\n\n        if cond1 and cond2:\n            return True\n        return False\n        \n\n        \n\n        ","question":"<p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>\n\n<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>\n\n<ul>\n\t<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword=\"string-prefix\">prefix</span> and a <span data-keyword=\"string-suffix\">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>\n</ul>\n\n<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>\n\n<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i, j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.\ni = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.\ni = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.\ni = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.\nTherefore, the answer is 4.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.\ni = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.\nTherefore, the answer is 2.  </pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.\nTherefore, the answer is 0.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists only of lowercase English letters.</li>\n</ul>\n","platform":"leetcode","difficulty":"Easy","tags":["array","string","trie","rolling-hash","string-matching","hash-function"],"qlink":"https://leetcode.com/problems/count-prefix-and-suffix-pairs-i","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/count-prefix-and-suffix-pairs-i"},"counting-words-with-a-given-prefix":{"date":"Thu Jan 09 2025","questiontitle":"counting-words-with-a-given-prefix","code":"class Solution:\n    def prefixCount(self, words: List[str], pref: str) -> int:\n\n        count = 0\n        for word in words:\n            if self.isPrefix(pref, word):\n                count += 1\n\n        return count\n    \n    def isPrefix(self, pref, word):\n\n        if len(word) < len(pref):\n            return False\n        \n        for i in range(len(pref)):\n            if word[i] != pref[i]:\n                return False\n        \n        return True\n\n\n\n\n        \n\n        ","question":"<p>You are given an array of strings <code>words</code> and a string <code>pref</code>.</p>\n\n<p>Return <em>the number of strings in </em><code>words</code><em> that contain </em><code>pref</code><em> as a <strong>prefix</strong></em>.</p>\n\n<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;pay&quot;,&quot;<strong><u>at</u></strong>tention&quot;,&quot;practice&quot;,&quot;<u><strong>at</strong></u>tend&quot;], <code>pref </code>= &quot;at&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The 2 strings that contain &quot;at&quot; as a prefix are: &quot;<u><strong>at</strong></u>tention&quot; and &quot;<u><strong>at</strong></u>tend&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;win&quot;,&quot;loops&quot;,&quot;success&quot;], <code>pref </code>= &quot;code&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no strings that contain &quot;code&quot; as a prefix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> and <code>pref</code> consist of lowercase English letters.</li>\n</ul>\n","platform":"leetcode","difficulty":"Easy","tags":["array","string","string-matching"],"qlink":"https://leetcode.com/problems/counting-words-with-a-given-prefix","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/counting-words-with-a-given-prefix"},"word-subsets":{"date":"Fri Jan 10 2025","questiontitle":"word-subsets","code":"class Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n\n        freq2 = [0] * 26\n\n        for word in words2:\n\n            currFreq = [0] * 26\n            for char in word:\n\n                index = ord(char) - ord('a')\n                currFreq[index] += 1\n            \n            for i in range(26):\n                freq2[i] = max(freq2[i], currFreq[i])\n        \n        ans = []\n\n        for word in words1:\n\n            currFreq = [0] * 26\n\n            for char in word:\n                index = ord(char) - ord('a')\n                currFreq[index] += 1\n\n            isValid = True\n            for i in range(26):\n                if currFreq[i] < freq2[i]:\n                    isValid = False\n                    break\n            \n            if isValid:\n                ans.append(word)\n        \n        return ans\n\n\n\n        \n        ","question":"<p>You are given two string arrays <code>words1</code> and <code>words2</code>.</p>\n\n<p>A string <code>b</code> is a <strong>subset</strong> of string <code>a</code> if every letter in <code>b</code> occurs in <code>a</code> including multiplicity.</p>\n\n<ul>\n\t<li>For example, <code>&quot;wrr&quot;</code> is a subset of <code>&quot;warrior&quot;</code> but is not a subset of <code>&quot;world&quot;</code>.</li>\n</ul>\n\n<p>A string <code>a</code> from <code>words1</code> is <strong>universal</strong> if for every string <code>b</code> in <code>words2</code>, <code>b</code> is a subset of <code>a</code>.</p>\n\n<p>Return an array of all the <strong>universal</strong> strings in <code>words1</code>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words1 = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], words2 = [&quot;e&quot;,&quot;o&quot;]\n<strong>Output:</strong> [&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words1 = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], words2 = [&quot;l&quot;,&quot;e&quot;]\n<strong>Output:</strong> [&quot;apple&quot;,&quot;google&quot;,&quot;leetcode&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words1.length, words2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words1[i].length, words2[i].length &lt;= 10</code></li>\n\t<li><code>words1[i]</code> and <code>words2[i]</code> consist only of lowercase English letters.</li>\n\t<li>All the strings of <code>words1</code> are <strong>unique</strong>.</li>\n</ul>\n","platform":"leetcode","difficulty":"Medium","tags":["array","hash-table","string"],"qlink":"https://leetcode.com/problems/word-subsets","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/word-subsets"},"maximum-frequency-of-an-element-after-performing-operations-i":{"date":"Fri Jan 10 2025","questiontitle":"maximum-frequency-of-an-element-after-performing-operations-i","code":"class Solution:\n    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:\n\n        nums.sort()\n\n        freqMap = defaultdict(int)\n        minVal = float('inf')\n        maxVal = -1\n\n        for num in nums:\n            freqMap[num] += 1\n            minVal = min(minVal, num)\n            maxVal = max(maxVal, num)\n\n\n \n        maxFreq = 0\n        n = len(nums)\n\n        for num in range(minVal, maxVal + 1):\n\n\n\n            leftMost = bisect.bisect_left(nums, num - k)\n            rightMost = bisect.bisect_left(nums, num + k + 1) - 1\n\n            currLenOfSameNum = freqMap[num]\n            totalLen = rightMost - leftMost + 1\n\n            toChange = max(0, totalLen - currLenOfSameNum)\n            toChange = min(toChange, numOperations)\n\n            maxFreq = max(maxFreq, currLenOfSameNum + toChange)\n \n            \n    \n        return maxFreq\n\n\n        ","question":"<p>You are given an integer array <code>nums</code> and two integers <code>k</code> and <code>numOperations</code>.</p>\n\n<p>You must perform an <strong>operation</strong> <code>numOperations</code> times on <code>nums</code>, where in each operation you:</p>\n\n<ul>\n\t<li>Select an index <code>i</code> that was <strong>not</strong> selected in any previous operations.</li>\n\t<li>Add an integer in the range <code>[-k, k]</code> to <code>nums[i]</code>.</li>\n</ul>\n\n<p>Return the <strong>maximum</strong> possible <span data-keyword=\"frequency-array\">frequency</span> of any element in <code>nums</code> after performing the <strong>operations</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,4,5], k = 1, numOperations = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>We can achieve a maximum frequency of two by:</p>\n\n<ul>\n\t<li>Adding 0 to <code>nums[1]</code>. <code>nums</code> becomes <code>[1, 4, 5]</code>.</li>\n\t<li>Adding -1 to <code>nums[2]</code>. <code>nums</code> becomes <code>[1, 4, 4]</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [5,11,20,20], k = 5, numOperations = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>We can achieve a maximum frequency of two by:</p>\n\n<ul>\n\t<li>Adding 0 to <code>nums[1]</code>.</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= numOperations &lt;= nums.length</code></li>\n</ul>\n","platform":"leetcode","difficulty":"Medium","tags":["array","binary-search","sliding-window","sorting","prefix-sum"],"qlink":"https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/maximum-frequency-of-an-element-after-performing-operations-i"},"reverse-pairs":{"date":"Thu Jan 23 2025","questiontitle":"reverse-pairs","code":"class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n\n        return self.mergeSort(nums, 0, len(nums)-1)\n\n        # Merge\n    \n    def mergeSort(self, arr, low, high):\n\n        if low < high:\n            mid = (low + high) >> 1\n\n            cnt = 0\n\n            cnt += self.mergeSort(arr, low, mid)\n            cnt += self.mergeSort(arr, mid+1, high)\n\n            cnt += self.merge(arr, low, mid, high)\n\n            return cnt\n        else:\n            return 0\n    \n    def merge(self, arr, low, mid, high):\n        ans = 0\n        right = mid + 1\n        for left in range(low, mid + 1):\n            while right <= high and arr[left] > 2 * arr[right]:\n                right += 1\n            ans += (right - mid - 1)\n    \n        # Merging process\n        temp = []\n        i, j = low, mid + 1\n        while i <= mid and j <= high:\n            if arr[i] <= arr[j]:\n                temp.append(arr[i])\n                i += 1\n            else:\n                temp.append(arr[j])\n                j += 1\n        \n        while i <= mid:\n            temp.append(arr[i])\n            i += 1\n        \n        while j <= high:\n            temp.append(arr[j])\n            j += 1\n        \n        # Place sorted elements back into the original array\n        for i in range(len(temp)):\n            arr[low + i] = temp[i]\n    \n        return ans\n    \n    \n    \n    \n    \n    \n        \n    \n            ","question":"<p>Given an integer array <code>nums</code>, return <em>the number of <strong>reverse pairs</strong> in the array</em>.</p>\n\n<p>A <strong>reverse pair</strong> is a pair <code>(i, j)</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; nums.length</code> and</li>\n\t<li><code>nums[i] &gt; 2 * nums[j]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The reverse pairs are:\n(1, 4) --&gt; nums[1] = 3, nums[4] = 1, 3 &gt; 2 * 1\n(3, 4) --&gt; nums[3] = 3, nums[4] = 1, 3 &gt; 2 * 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,3,5,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The reverse pairs are:\n(1, 4) --&gt; nums[1] = 4, nums[4] = 1, 4 &gt; 2 * 1\n(2, 4) --&gt; nums[2] = 3, nums[4] = 1, 3 &gt; 2 * 1\n(3, 4) --&gt; nums[3] = 5, nums[4] = 1, 5 &gt; 2 * 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n","platform":"leetcode","difficulty":"Hard","tags":["array","binary-search","divide-and-conquer","binary-indexed-tree","segment-tree","merge-sort","ordered-set"],"qlink":"https://leetcode.com/problems/reverse-pairs","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/reverse-pairs"}}