{"two-sum":{"date":"Mon Jan 06 2025","questiontitle":"two-sum","code":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n\n        map = {}\n        for i in range(len(nums)):\n\n            diff = target - nums[i]\n            if diff in map:\n                return [map[diff], i]\n            map[nums[i]] = i\n\n        ","question":"<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than <code>O(n<sup>2</sup>)</code><font face=\"monospace\">&nbsp;</font>time complexity?","platform":"leetcode","difficulty":"Easy","tags":["array","hash-table"],"qlink":"https://leetcode.com/problems/two-sum","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/two-sum"},"Sum-of-Natural-Numbers":{"date":"Mon Jan 06 2025","questiontitle":"Sum-of-Natural-Numbers","code":"\nclass Solution:\n    def seriesSum(self, n : int) -> int:\n        # code here\n        \n        return (n * (n+1)) // 2\n        \n\n\n\n#{ \n # Driver Code Starts\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n\n        n = int(input())\n\n        obj = Solution()\n        res = obj.seriesSum(n)\n\n        print(res)\n        print(\"~\")\n\n# } Driver Code Ends","question":"<div class=\"problems_problem_content__Xm_eO\"><p><span style=\"font-size: 14pt;\"><span style=\"color: #1e2229; font-family: Nunito; background-color: #ffffff;\">Given an integer </span><span style=\"box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: #1e2229; background-color: #ffffff; font-family: var(--gfg-font-secondary) !important;\">n</span><span style=\"color: #1e2229; font-family: Nunito; background-color: #ffffff;\">, your task is to compute the sum of all natural numbers from 1 to n (inclusive). If n is 0, the sum should be 0.</span></span></p>\n<p><span style=\"font-size: 14pt;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 14pt;\"><strong>Input: </strong>n = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> For n = 1, the sum will be 1.\n</span></pre>\n<pre><span style=\"font-size: 14pt;\"><strong>Input: </strong>n = 5\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> For n = 5, sum will be 15. 1 + 2 + 3 + 4 + 5 = 15.</span></pre>\n<p><span style=\"font-size: 14pt;\"><strong>Constraints:</strong><br>1 &lt;= n &lt;= 10<sup>4</sup></span></p></div>","platform":"leetcode","difficulty":"Difficulty: Basic","tags":[],"qlink":"https://leetcode.com/problems/Sum-of-Natural-Numbers","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/Sum-of-Natural-Numbers"},"string-matching-in-an-array":{"date":"Tue Jan 07 2025","questiontitle":"string-matching-in-an-array","code":"class Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n\n        words.sort(key = lambda x:(len(x)))\n\n        ans = []\n        n = len(words)\n\n        for i in range(n):\n\n            for j in range(i+1, n):\n\n                if words[i] in words[j]:\n                    ans.append(words[i])\n                    break\n        \n        return ans\n        ","question":"<p>Given an array of string <code>words</code>, return <em>all strings in </em><code>words</code><em> that is a <strong>substring</strong> of another word</em>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters within a string</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]\n<strong>Output:</strong> [&quot;as&quot;,&quot;hero&quot;]\n<strong>Explanation:</strong> &quot;as&quot; is substring of &quot;mass&quot; and &quot;hero&quot; is substring of &quot;superhero&quot;.\n[&quot;hero&quot;,&quot;as&quot;] is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;]\n<strong>Output:</strong> [&quot;et&quot;,&quot;code&quot;]\n<strong>Explanation:</strong> &quot;et&quot;, &quot;code&quot; are substring of &quot;leetcode&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> No string of words is substring of another string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> contains only lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>\n</ul>\n","platform":"leetcode","difficulty":"Easy","tags":["array","string","string-matching"],"qlink":"https://leetcode.com/problems/string-matching-in-an-array","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/string-matching-in-an-array"},"count-prefix-and-suffix-pairs-i":{"date":"Wed Jan 08 2025","questiontitle":"count-prefix-and-suffix-pairs-i","code":"class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n\n        #words.sort(key = lambda x:(len(x)))\n        n = len(words)\n        ans = 0\n\n        for i in range(n):\n            for j in range(i+1, n):\n\n                if self.isPrefixAndSuffix(words[i], words[j]):\n                    ans += 1\n        \n        return ans\n\n    def isPrefixAndSuffix(self, str1, str2):\n\n        n = len(str1)\n\n        if len(str2) < n:\n            return False\n\n        print(str1)\n        print(str2)\n\n        print(str2[:n])\n        print(str2[-n:])\n        \n        cond1 = str1 == str2[:n]\n        cond2 = str1 == str2[-n:]\n\n        if cond1 and cond2:\n            return True\n        return False\n        \n\n        \n\n        ","question":"<p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>\n\n<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>\n\n<ul>\n\t<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword=\"string-prefix\">prefix</span> and a <span data-keyword=\"string-suffix\">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>\n</ul>\n\n<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>\n\n<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i, j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.\ni = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.\ni = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.\ni = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.\nTherefore, the answer is 4.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.\ni = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.\nTherefore, the answer is 2.  </pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.\nTherefore, the answer is 0.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists only of lowercase English letters.</li>\n</ul>\n","platform":"leetcode","difficulty":"Easy","tags":["array","string","trie","rolling-hash","string-matching","hash-function"],"qlink":"https://leetcode.com/problems/count-prefix-and-suffix-pairs-i","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/count-prefix-and-suffix-pairs-i"},"counting-words-with-a-given-prefix":{"date":"Thu Jan 09 2025","questiontitle":"counting-words-with-a-given-prefix","code":"class Solution:\n    def prefixCount(self, words: List[str], pref: str) -> int:\n\n        count = 0\n        for word in words:\n            if self.isPrefix(pref, word):\n                count += 1\n\n        return count\n    \n    def isPrefix(self, pref, word):\n\n        if len(word) < len(pref):\n            return False\n        \n        for i in range(len(pref)):\n            if word[i] != pref[i]:\n                return False\n        \n        return True\n\n\n\n\n        \n\n        ","question":"<p>You are given an array of strings <code>words</code> and a string <code>pref</code>.</p>\n\n<p>Return <em>the number of strings in </em><code>words</code><em> that contain </em><code>pref</code><em> as a <strong>prefix</strong></em>.</p>\n\n<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;pay&quot;,&quot;<strong><u>at</u></strong>tention&quot;,&quot;practice&quot;,&quot;<u><strong>at</strong></u>tend&quot;], <code>pref </code>= &quot;at&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The 2 strings that contain &quot;at&quot; as a prefix are: &quot;<u><strong>at</strong></u>tention&quot; and &quot;<u><strong>at</strong></u>tend&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;win&quot;,&quot;loops&quot;,&quot;success&quot;], <code>pref </code>= &quot;code&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no strings that contain &quot;code&quot; as a prefix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> and <code>pref</code> consist of lowercase English letters.</li>\n</ul>\n","platform":"leetcode","difficulty":"Easy","tags":["array","string","string-matching"],"qlink":"https://leetcode.com/problems/counting-words-with-a-given-prefix","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/counting-words-with-a-given-prefix"},"word-subsets":{"date":"Fri Jan 10 2025","questiontitle":"word-subsets","code":"class Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n\n        freq2 = [0] * 26\n\n        for word in words2:\n\n            currFreq = [0] * 26\n            for char in word:\n\n                index = ord(char) - ord('a')\n                currFreq[index] += 1\n            \n            for i in range(26):\n                freq2[i] = max(freq2[i], currFreq[i])\n        \n        ans = []\n\n        for word in words1:\n\n            currFreq = [0] * 26\n\n            for char in word:\n                index = ord(char) - ord('a')\n                currFreq[index] += 1\n\n            isValid = True\n            for i in range(26):\n                if currFreq[i] < freq2[i]:\n                    isValid = False\n                    break\n            \n            if isValid:\n                ans.append(word)\n        \n        return ans\n\n\n\n        \n        ","question":"<p>You are given two string arrays <code>words1</code> and <code>words2</code>.</p>\n\n<p>A string <code>b</code> is a <strong>subset</strong> of string <code>a</code> if every letter in <code>b</code> occurs in <code>a</code> including multiplicity.</p>\n\n<ul>\n\t<li>For example, <code>&quot;wrr&quot;</code> is a subset of <code>&quot;warrior&quot;</code> but is not a subset of <code>&quot;world&quot;</code>.</li>\n</ul>\n\n<p>A string <code>a</code> from <code>words1</code> is <strong>universal</strong> if for every string <code>b</code> in <code>words2</code>, <code>b</code> is a subset of <code>a</code>.</p>\n\n<p>Return an array of all the <strong>universal</strong> strings in <code>words1</code>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words1 = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], words2 = [&quot;e&quot;,&quot;o&quot;]\n<strong>Output:</strong> [&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words1 = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], words2 = [&quot;l&quot;,&quot;e&quot;]\n<strong>Output:</strong> [&quot;apple&quot;,&quot;google&quot;,&quot;leetcode&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words1.length, words2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words1[i].length, words2[i].length &lt;= 10</code></li>\n\t<li><code>words1[i]</code> and <code>words2[i]</code> consist only of lowercase English letters.</li>\n\t<li>All the strings of <code>words1</code> are <strong>unique</strong>.</li>\n</ul>\n","platform":"leetcode","difficulty":"Medium","tags":["array","hash-table","string"],"qlink":"https://leetcode.com/problems/word-subsets","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/word-subsets"},"maximum-frequency-of-an-element-after-performing-operations-i":{"date":"Fri Jan 10 2025","questiontitle":"maximum-frequency-of-an-element-after-performing-operations-i","code":"class Solution:\n    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:\n\n        nums.sort()\n\n        freqMap = defaultdict(int)\n        minVal = float('inf')\n        maxVal = -1\n\n        for num in nums:\n            freqMap[num] += 1\n            minVal = min(minVal, num)\n            maxVal = max(maxVal, num)\n\n\n \n        maxFreq = 0\n        n = len(nums)\n\n        for num in range(minVal, maxVal + 1):\n\n\n\n            leftMost = bisect.bisect_left(nums, num - k)\n            rightMost = bisect.bisect_left(nums, num + k + 1) - 1\n\n            currLenOfSameNum = freqMap[num]\n            totalLen = rightMost - leftMost + 1\n\n            toChange = max(0, totalLen - currLenOfSameNum)\n            toChange = min(toChange, numOperations)\n\n            maxFreq = max(maxFreq, currLenOfSameNum + toChange)\n \n            \n    \n        return maxFreq\n\n\n        ","question":"<p>You are given an integer array <code>nums</code> and two integers <code>k</code> and <code>numOperations</code>.</p>\n\n<p>You must perform an <strong>operation</strong> <code>numOperations</code> times on <code>nums</code>, where in each operation you:</p>\n\n<ul>\n\t<li>Select an index <code>i</code> that was <strong>not</strong> selected in any previous operations.</li>\n\t<li>Add an integer in the range <code>[-k, k]</code> to <code>nums[i]</code>.</li>\n</ul>\n\n<p>Return the <strong>maximum</strong> possible <span data-keyword=\"frequency-array\">frequency</span> of any element in <code>nums</code> after performing the <strong>operations</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,4,5], k = 1, numOperations = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>We can achieve a maximum frequency of two by:</p>\n\n<ul>\n\t<li>Adding 0 to <code>nums[1]</code>. <code>nums</code> becomes <code>[1, 4, 5]</code>.</li>\n\t<li>Adding -1 to <code>nums[2]</code>. <code>nums</code> becomes <code>[1, 4, 4]</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [5,11,20,20], k = 5, numOperations = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>We can achieve a maximum frequency of two by:</p>\n\n<ul>\n\t<li>Adding 0 to <code>nums[1]</code>.</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= numOperations &lt;= nums.length</code></li>\n</ul>\n","platform":"leetcode","difficulty":"Medium","tags":["array","binary-search","sliding-window","sorting","prefix-sum"],"qlink":"https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/maximum-frequency-of-an-element-after-performing-operations-i"},"reverse-pairs":{"date":"Thu Jan 23 2025","questiontitle":"reverse-pairs","code":"class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n\n        return self.mergeSort(nums, 0, len(nums)-1)\n\n        # Merge\n    \n    def mergeSort(self, arr, low, high):\n\n        if low < high:\n            mid = (low + high) >> 1\n\n            cnt = 0\n\n            cnt += self.mergeSort(arr, low, mid)\n            cnt += self.mergeSort(arr, mid+1, high)\n\n            cnt += self.merge(arr, low, mid, high)\n\n            return cnt\n        else:\n            return 0\n    \n    def merge(self, arr, low, mid, high):\n        ans = 0\n        right = mid + 1\n        for left in range(low, mid + 1):\n            while right <= high and arr[left] > 2 * arr[right]:\n                right += 1\n            ans += (right - mid - 1)\n    \n        # Merging process\n        temp = []\n        i, j = low, mid + 1\n        while i <= mid and j <= high:\n            if arr[i] <= arr[j]:\n                temp.append(arr[i])\n                i += 1\n            else:\n                temp.append(arr[j])\n                j += 1\n        \n        while i <= mid:\n            temp.append(arr[i])\n            i += 1\n        \n        while j <= high:\n            temp.append(arr[j])\n            j += 1\n        \n        # Place sorted elements back into the original array\n        for i in range(len(temp)):\n            arr[low + i] = temp[i]\n    \n        return ans\n    \n    \n    \n    \n    \n    \n        \n    \n            ","question":"<p>Given an integer array <code>nums</code>, return <em>the number of <strong>reverse pairs</strong> in the array</em>.</p>\n\n<p>A <strong>reverse pair</strong> is a pair <code>(i, j)</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; nums.length</code> and</li>\n\t<li><code>nums[i] &gt; 2 * nums[j]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The reverse pairs are:\n(1, 4) --&gt; nums[1] = 3, nums[4] = 1, 3 &gt; 2 * 1\n(3, 4) --&gt; nums[3] = 3, nums[4] = 1, 3 &gt; 2 * 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,3,5,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The reverse pairs are:\n(1, 4) --&gt; nums[1] = 4, nums[4] = 1, 4 &gt; 2 * 1\n(2, 4) --&gt; nums[2] = 3, nums[4] = 1, 3 &gt; 2 * 1\n(3, 4) --&gt; nums[3] = 5, nums[4] = 1, 5 &gt; 2 * 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n","platform":"leetcode","difficulty":"Hard","tags":["array","binary-search","divide-and-conquer","binary-indexed-tree","segment-tree","merge-sort","ordered-set"],"qlink":"https://leetcode.com/problems/reverse-pairs","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/reverse-pairs"},"count-of-smaller-numbers-after-self":{"date":"Thu Jan 23 2025","questiontitle":"count-of-smaller-numbers-after-self","code":"\"\"\"\n\nApproch\nThis kind of problems which require cnt of less than or greater than with some sorting techinuq\n\ninvolves\n1. N ^ 2\n2. BST\n3. BIT\n4. Merge Sort\n\nif overall simple cnt variable is enough\nsince we requrie for each element and also while sorting order changes\nwe have to maintain indexArr\n\nTC : O(2nlogn)\nSC : O(n)\n\n\n\"\"\"\n\n\nclass Solution:\n    def countSmaller(self, nums: List[int]) -> List[int]:\n\n        n = len(nums)\n        ans = [0] * n\n\n        indexArr = list(range(n))\n\n        self.mergeSort(nums, 0, n-1, ans, indexArr)\n        return ans\n    \n    def mergeSort(self, nums, low, high, ans, indexArr):\n        if low >= high:\n            return\n\n        mid = (low + high) >> 1\n        self.mergeSort(nums, low, mid, ans, indexArr)\n        self.mergeSort(nums, mid+1, high, ans, indexArr)\n        self.merge(nums, low, mid, high, ans, indexArr)\n\n    def merge(self, nums, low, mid, high, ans, indexArr):\n\n        i = low\n        j = mid + 1\n        temp = []\n        rightCnt = 0\n        # the above represents the numbers of elements in the right side which are less than value\n\n        while i <= mid and j <= high:\n            if nums[indexArr[i]] > nums[indexArr[j]]:\n                temp.append(indexArr[j])\n                rightCnt += 1\n                j += 1\n            else:\n                ans[indexArr[i]] += rightCnt\n                temp.append(indexArr[i])\n                i += 1\n        \n        while i <= mid:\n            temp.append(indexArr[i])\n            ans[indexArr[i]] += rightCnt\n            i += 1\n        while j <= high:\n            temp.append(indexArr[j])\n            j += 1\n        \n        for i in range(len(temp)):\n            indexArr[low + i] = temp[i]\n\n\n                \n\n        \n        \n        \n\n\n\n\n    \n\n\n        \n        ","question":"<p>Given an integer array <code>nums</code>, return<em> an integer array </em><code>counts</code><em> where </em><code>counts[i]</code><em> is the number of smaller elements to the right of </em><code>nums[i]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,6,1]\n<strong>Output:</strong> [2,1,1,0]\n<strong>Explanation:</strong>\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\nTo the right of 2 there is only <b>1</b> smaller element (1).\nTo the right of 6 there is <b>1</b> smaller element (1).\nTo the right of 1 there is <b>0</b> smaller element.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-1]\n<strong>Output:</strong> [0,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n","platform":"leetcode","difficulty":"Hard","tags":["array","binary-search","divide-and-conquer","binary-indexed-tree","segment-tree","merge-sort","ordered-set"],"qlink":"https://leetcode.com/problems/count-of-smaller-numbers-after-self","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/count-of-smaller-numbers-after-self"},"confirmation-rate":{"date":"Thu Jan 23 2025","questiontitle":"confirmation-rate","code":"# Write your MySQL query statement below\n\n\n\n-- SELECT *\n-- FROM\n-- Signups s1\n-- LEFT JOIN (\n--     SELECT c2.user_id, (*) as total\n--     FROM Confirmations c2\n--     GROUP BY c2.user_id\n--     LEFT JOIN\n    \n-- )\n\n# FIRST I WILL MAKE A TABLE USER_ID, TOTAL_ATTEMPS, SUCCESFULL\n\nSELECT s1.user_id, ROUND(COALESCE(f.success, 0) / COALESCE(f.total, 1), 2) as confirmation_rate\nFROM Signups s1\nLEFT JOIN\n(\n\n\nSELECT c1.user_id, COUNT(*) as total, COALESCE(c3.success, 0) as success\nFROM Confirmations c1\nLEFT JOIN\n(\n    SELECT c2.user_id, COUNT(*) as success\n    FROM Confirmations c2\n    WHERE c2.action = 'confirmed'\n    GROUP BY c2.user_id\n) as c3\nON c1.user_id = c3.user_id\nGROUP BY c1.user_id\n) AS f\nON f.user_id = s1.user_id\n","question":"<p>Table: <code>Signups</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\nuser_id is the column of unique values for this table.\nEach row contains information about the signup time for the user with ID user_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Confirmations</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n| action         | ENUM     |\n+----------------+----------+\n(user_id, time_stamp) is the primary key (combination of columns with unique values) for this table.\nuser_id is a foreign key (reference column) to the Signups table.\naction is an ENUM (category) of the type (&#39;confirmed&#39;, &#39;timeout&#39;)\nEach row of this table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (&#39;confirmed&#39;) or expired without confirming (&#39;timeout&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>The <strong>confirmation rate</strong> of a user is the number of <code>&#39;confirmed&#39;</code> messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is <code>0</code>. Round the confirmation rate to <strong>two decimal</strong> places.</p>\n\n<p>Write a solution to find the <strong>confirmation rate</strong> of each user.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSignups table:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 3       | 2020-03-21 10:16:13 |\n| 7       | 2020-01-04 13:57:59 |\n| 2       | 2020-07-29 23:09:44 |\n| 6       | 2020-12-09 10:39:37 |\n+---------+---------------------+\nConfirmations table:\n+---------+---------------------+-----------+\n| user_id | time_stamp          | action    |\n+---------+---------------------+-----------+\n| 3       | 2021-01-06 03:30:46 | timeout   |\n| 3       | 2021-07-14 14:00:00 | timeout   |\n| 7       | 2021-06-12 11:57:29 | confirmed |\n| 7       | 2021-06-13 12:58:28 | confirmed |\n| 7       | 2021-06-14 13:59:27 | confirmed |\n| 2       | 2021-01-22 00:00:00 | confirmed |\n| 2       | 2021-02-28 23:59:59 | timeout   |\n+---------+---------------------+-----------+\n<strong>Output:</strong> \n+---------+-------------------+\n| user_id | confirmation_rate |\n+---------+-------------------+\n| 6       | 0.00              |\n| 3       | 0.00              |\n| 7       | 1.00              |\n| 2       | 0.50              |\n+---------+-------------------+\n<strong>Explanation:</strong> \nUser 6 did not request any confirmation messages. The confirmation rate is 0.\nUser 3 made 2 requests and both timed out. The confirmation rate is 0.\nUser 7 made 3 requests and all were confirmed. The confirmation rate is 1.\nUser 2 made 2 requests where one was confirmed and the other timed out. The confirmation rate is 1 / 2 = 0.5.\n</pre>\n","platform":"leetcode","difficulty":"Medium","tags":["database"],"qlink":"https://leetcode.com/problems/confirmation-rate","githublink":"https://github.com/konavivekramakrishna/AlgoPrep/tree/main/confirmation-rate"}}